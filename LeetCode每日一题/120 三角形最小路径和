import java.lang.* //函数math.min
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int n = triangle.size();    
        int[][] dp = new int[n + 1][n + 1];//新建的整数元素默认值都为0，最后一层的递归后加的是0；dp[i][j] 表示从点 (i, j) 到底边的最小路径和。
        for (int i = n - 1; i >= 0; i--) {// 从三角形的最后一行开始递推。
            for (int j = 0; j <= i; j++) {
                dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle.get(i).get(j);
            }
        }
        return dp[0][0];
    }
}
/*** 实际递推中我们发现，计算 dp[i][j] 时，只用到了下一行的 dp[i + 1][j] 和 dp[i + 1][j + 1]。
*因此 dp数组不需要定义 N行，只要定义 1行就阔以啦。
*所以我们稍微修改一下上述代码，将 i所在的维度去掉（如下），就可以将 O(N^2) 的空间复杂度优化成 O(N) 啦
***/
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int n = triangle.size();
        int[] dp = new int[n + 1];//新建的整数元素默认值都为0
        for (int i = n - 1; i >= 0; i--) {
            for (int j = 0; j <= i; j++) {
                dp[j] = Math.min(dp[j], dp[j + 1]) + triangle.get(i).get(j);
            }
        }
        return dp[0];
    }
}
